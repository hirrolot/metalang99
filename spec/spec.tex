\documentclass[12pt]{article}

\usepackage{hyperref}
\usepackage{float}
\usepackage{bussproofs}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ntheorem}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{tabularx}
\usepackage[english]{babel}

\theoremstyle{break}
\newtheorem{notation}{Notation}
\newtheorem{example}{Example}

\addbibresource{references.bib}

\floatstyle{boxed}
\restylefloat{figure}

\begin{document}

\title{Macrolop Specification}
\date{\today}
\author{Temirkhan Myrzamadi \\ e-mail: \href{mailto:hirrolot@gmail.com}{hirrolot@gmail.com}}
\maketitle

\begin{abstract}
This paper formally describes the form and execution of metaprograms written in Macrolop,
an embedded metalanguage aimed at language-oriented programming in C. It is \textbf{not}
designed as a user-friendly overview -- see the official repository \cite{Macrolop}.
\end{abstract}

\tableofcontents

\newpage

\section{EBNF Grammar}

\begin{figure}[H]
    \caption{Grammar rules}

\begin{minted}{bnf}
<eval> ::= "MACROLOP_EVAL(" { <term> }* ")" ;

<term> ::= "call(" <op> "," { <term> }* ")"
         | "v(" <preprocessor-token-list> ")" ;

<op>   ::= <ident> | { <term> }+ ;
\end{minted}

\end{figure}

A metaprogram in Macrolop consists of a possibly empty sequence of terms, each of which
is either a macro call or just a value.

Notes:

\begin{itemize}
    \item The grammar above describes metaprograms already expanded by the C preprocessor,
    except for \texttt{MACROLOP\_EVAL}, \texttt{call}, and \texttt{v}.
    \item \texttt{call} accepts \texttt{op} either as an identifier or as a non-empty
    sequence of terms that reduces to an identifier.
    \item \texttt{call} accepts arguments without a separator. This is intentional: suppose
    you need to generate arguments for some macro and then call it. Without separators, all
    arguments can be generated uniformly, unlike separation by commas where the last argument
    need no comma after itself.
\end{itemize}

However, the \texttt{call} syntax hurts IDE support: bad code formatting, no parameters
documentation highlighting, et cetera. The workaround is to define a wrapper around
an implementation macro like this:

\begin{minted}{c}
/// A documentation string here.
#define FOO(a, b, c) FOO_REAL(a b c)
#define FOO_REAL(a, b, c) // The actual implementation here.
\end{minted}

Then \texttt{FOO} can be called as \texttt{FOO(v(1), v(2), v(3))}.

All the public std's macros follow this convention, and moreover, std's public
higher-order macros require so for supplied user macros.

\section{Notations}

\begin{notation}[Concrete sequence]
    \begin{itemize}
        \item $\overline{x}$ denotes a concrete sequence $x_1 \ldots x_n$ (either of terms
        or preprocessor tokens). For example:
        \begin{itemize}
            \item $v(abc) \ call(FOO, v(123)) \ v(u \ 8 \ 9)$ (of Macrolop terms)
            \item $abc \ 13 \ "hello" \ + \ -$ (of preprocessor tokens)
        \end{itemize}
        \item $S \ x$ is appending an element or sequence $x$ to a sequence $S$. For
        example:
        \begin{itemize}
            \item let $S$ be $v(1) \ v(2)$ and $x$ is $v(3)$, then $S \ x$ is $v(1) \ v(2) \ v(3)$
            (appending an element)
            \item let $S$ be $v(1) \ v(2)$ and $x$ is $v(3) \ v(abc)$, then $S \ x$ is $v(1) \ v(2) \ v(3) \\ v(abc)$
            (appending a sequence)
        \end{itemize}
        \item $comma\mbox{-}sep$ places $v(,)$ between terms in a concrete sequence of terms:\\
        $comma\mbox{-}sep(v(1) \ v(2) \ call(FOO, v(a)))$ results in\\
        $v(1) \ v(,) \ v(2) \ v(,) \ call(FOO, v(a))$.
    \end{itemize}
\end{notation}

\begin{notation}[Reduction step]
    $\to$ denotes a single step of reduction (computation).
\end{notation}

\begin{notation}[Multiple reduction steps]
    $\twoheadrightarrow$ denotes one or more single evaluation steps, e.g.
    $\overline{t} \twoheadrightarrow \overline{t'}$ is the same as
    $\overline{t} \to \ldots \to \overline{t'}$.
\end{notation}

\begin{notation}[Meta-variables]
    \ \\
    \begin{tabular}{|c|c|}
        \hline
        \texttt{tok} & C preprocessor token \\
        \texttt{ident} & C preprocessor identifier \\
        \texttt{t} & Macrolop term \\
        \texttt{a} & Macrolop term used as an argument \\
        \hline
    \end{tabular}
\end{notation}

\section{Reduction Semantics}

We define reduction semantics for Macrolop. The abstract machine executes configurations
of the form $\langle K; A; C \rangle$:

\begin{itemize}
    \item $K$ is a continuation of the form $\langle K; A; C \rangle$, where
    $C$ includes the $?$ sign denoting a result passed into a continuation.
    For example, let $K$ be $\langle K'; (1, 2, 3); v(x) \ ? \rangle$,
    then $K(v(y))$ is $\langle K'; (1, 2, 3); v(x) \ v(y) \rangle$.

    \item A special continuation $halt$ terminates the abstract machine and
    substitutes itself with a provided result.

    \item $A$ is an accumulator, a concrete sequence of already computed
    results.

    \item $C$ (control) is a concrete sequence of terms upon which the abstract
    machine is operating right now.
\end{itemize}

And here are the computational rules:

\begin{figure}[H]
    \caption{Computational rules}

    \begin{align*}
        (v): \ & \langle K; A; v(\overline{tok}) \ \overline{t} \rangle & \to &
            \langle K; A \ \overline{tok}; \overline{t} \rangle \\
        (op): \ & \langle K; A; call(\overline{t}, \overline{a}) \ \overline{t'} \rangle & \to &
            \langle \langle K; A; call(?, \overline{a}) \ \overline{t'} \rangle; (); \overline{t} \rangle \\
        (args): \ & \langle K; A; call(ident, \overline{a}) \ \overline{t} \rangle & \to
            & \langle \langle K; A; ident(?) \ \overline{t} \rangle; (); comma\mbox{-}sep(\overline{a}) \rangle \\
        (end): \ & \langle K; A; \rangle & \to & K(A) \\
        (start): \ & MACROLOP\_EVAL(\overline{t}) & \to &
            \langle halt; (); \overline{t} \rangle
    \end{align*}
\end{figure}

A concrete sequence of terms provided to \texttt{MACROLOP\_EVAL} is evaluated sequentially till the end. A function's arguments
are evaluated before the function is applied, e.g. Macrolop follows applicative
evaluation strategy \cite{ApplicativeEvaluationStrategy}. When there's no more terms
to evaluate, a result is pasted where \texttt{MACROLOP\_EVAL} has been invoked.

Notes:

\begin{itemize}
    \item Look at $(args)$. Macrolop generates a usual C-style macro invocation with
    fully evaluated arguments, which will be then expanded by the C preprocessor, resulting
    in yet another concrete sequence of Macrolop terms to be evaluated by the computational
    rules.
    \item With the current implementation, at most $2^{14}$ reduction steps are
    possible. After exceeding this limit, compilation will likely fail.
\end{itemize}

\subsection{Examples}

Take the following code:

\begin{minted}{c}
#define X(op)        call(op, v(123))
#define CALL_X(_123) call(X, v(ID))
#define ID(x)        v(x)
\end{minted}

See how \texttt{call(X, v(CALL\_X))} is evaluated:

\begin{example}[Evaluation of terms]
\small
\begin{gather*}
    MACROLOP\_EVAL(call(X, v(CALL\_X))) \\
    \downarrow (start) \\
    \langle halt; (); call(X, v(CALL\_X)) \rangle \\
    \downarrow (args) \\
    \langle \langle halt; (); X(?) \rangle; (); v(CALL\_X) \rangle \\
    \downarrow (v) \\
    \langle \langle halt; (); X(?) \rangle; CALL\_X; \rangle \\
    \downarrow (end) \\
    \langle halt; (); call(CALL\_X, v(123)) \rangle \\
    \downarrow (args) \\
    \langle \langle halt; (); CALL\_X(?) \rangle; (); v(123) \rangle \\
    \downarrow (v) \\
    \langle \langle halt; (); CALL\_X(?) \rangle; 123; \rangle \\
    \downarrow (end) \\
    \langle halt; (); call(X, v(ID)) \rangle \\
    \downarrow (args) \\
    \langle \langle halt; (); X(?) \rangle; (); v(ID) \rangle \\
    \downarrow (v) \\
    \langle \langle halt; (); X(?) \rangle; ID; \rangle \\
    \downarrow (end) \\
    \langle halt; (); call(ID, v(123)) \rangle \\
    \downarrow (args) \\
    \langle \langle halt; (); ID(?) \rangle; (); v(123) \rangle \\
    \displaybreak
    \downarrow (v) \\
    \langle \langle halt; (); ID(?) \rangle; 123; \rangle \\
    \downarrow (end) \\
    \langle halt; (); v(123) \rangle \\
    \downarrow (v) \\
    \langle halt; 123; \rangle \\
    \downarrow (end) \\
    halt(123)
\end{gather*}
\normalsize
\end{example}

The analogous version written in ordinary C looks like this:

\begin{minted}{c}
#define X(op)        op(123)
#define CALL_X(_123) X(ID)
#define ID(x)        x
\end{minted}

However, unlike the Macrolop version above, it gets blocked due to the
second call to \texttt{X}:

$$
X(CALL\_X) \to CALL\_X(123) \to X(ID)
$$

\section{Caveats}

\begin{itemize}
\item Consider this scenario:
    \begin{itemize}
        \item You call \texttt{FOO(1, 2, 3)}
        \item It gets expanded by the C preprocessor (not by Macrolop)
        \item Its expansion contains \texttt{FOO}
    \end{itemize}
Then \texttt{FOO} gets blocked by the C preprocessor, e.g. Macrolop cannot handle ordinary
macro recursion; you must use \texttt{call} to be sure that recursive calls
will behave as expected. I therefore recommend to use only primitive C-style macros, e.g.
for performance reasons or because of you cannot express them in terms of Macrolop.
\end{itemize}

\emergencystretch=1em
\printbibliography

\end{document}
