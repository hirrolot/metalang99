\documentclass[12pt]{article}

\usepackage{hyperref}
\usepackage{float}
\usepackage{bussproofs}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[standard,thmmarks]{ntheorem}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage[english]{babel}

\theoremstyle{break}
\newtheorem{notation}{Notation}

\addbibresource{references.bib}

\floatstyle{boxed}
\restylefloat{figure}
\allowdisplaybreaks

\begin{document}

\title{Epilepsy Specification}
\date{\today}
\author{Hirrolot \\ e-mail: \href{mailto:hirrolot@gmail.com}{hirrolot@gmail.com}}
\maketitle

\begin{abstract}
This paper formally describes the form and execution of metaprograms written
Epilepsy, a metalanguage aimed at full-blown C/C++ preprocessor metaprogramming. This paper
is \textbf{not} designed as a user-friendly overview -- see the official repository
\cite{Epilepsy}.
\end{abstract}

\tableofcontents

\newpage

\section{EBNF Grammar}

\begin{figure}[H]
    \caption{Grammar rules}

\begin{minted}{bnf}
<eval> ::= "EPILEPSY_EVAL(" { <term> }* ")" ;

<term> ::= "EPILEPSY_CALL(" <op> "," { <term> }* ")"
         | "v(" <preprocessor-token-list> ")" ;

<op>   ::= <ident> | { <term> }+ ;
\end{minted}

\end{figure}

A metaprogram in Epilepsy consists of a possibly empty sequence of terms, each of which
is either a macro call or just a value.

Notes:

\begin{itemize}
    \item The grammar above describes metaprograms already expanded by the preprocessor,
    except for \texttt{EPILEPSY\_EVAL}, \texttt{EPILEPSY\_CALL}, and \texttt{v}.
    \item \texttt{EPILEPSY\_CALL} accepts \texttt{op} either as an identifier or as a non-empty
    sequence of terms that reduces to an identifier.
    \item \texttt{EPILEPSY\_CALL} accepts arguments of \texttt{op} without a separator.
\end{itemize}

The \texttt{EPILEPSY\_CALL} syntax hurts IDE support: bad code formatting, no parameters
documentation highlighting, et cetera. The workaround is to define a wrapper around
an implementation macro like this:

\begin{minted}{c}
/// The documentation string.
#define FOO(a, b, c) EPILEPSY_DESUGAR(FOO, a b c)
#define FOO_IMPL(a, b, c) // The implementation.
\end{minted}

Then \texttt{FOO} can be conveniently called as \texttt{FOO(v(1), v(2), v(3))}.

Notice that variadic macros are a bit special here. Their calls should be desugared as follows:

\begin{minted}{c}
/// The documentation string.
#define FOO(a, b, c, ...) \
    EPILEPSY_DESUGAR(FOO, a b c __VA_ARGS__)
#define FOO_IMPL(a, b, c, ...) // The implementation.
\end{minted}

Then \texttt{FOO} can be called as \texttt{FOO(v(1), v(2), v(3), v(5) v(6) v(7))};
\texttt{v(5) v(6) v(7)} are \textbf{not} separated by commas.

\section{Notations}

\begin{notation}[Sequence]
    \begin{itemize}
        \item $\overline{x} \coloneqq x_1 \ldots x_n$. Examples:
        \begin{itemize}
            \item Epilepsy terms: \texttt{v(abc) EPILEPSY\_CALL(FOO, v(123)) v(u 8 9)}
            \item Preprocessor tokens: \texttt{abc 13 "hello" + -}
        \end{itemize}
        \item $()$ denotes the empty sequence.
        \item Appending to a sequence:
        \begin{itemize}
            \item Appending an element: $S \ y \coloneqq x_1 \ldots x_n \ y$, where $S = x_1 \ldots x_n$
            \item Appending a sequence: $S_1 \ S_2 \coloneqq x_1 \ldots x_n \ y_1 \ldots y_m$, where $S_1 = x_1 \ldots x_n$
            and $S_2 = y_1 \ldots y_m$
        \end{itemize}
    \end{itemize}
\end{notation}

\begin{notation}[Reduction step]
    $\to$ denotes a single step of reduction (computation, evaluation).
\end{notation}

\begin{notation}[Meta-variables]
    \ \\
    \begin{tabular}{|c|c|}
        \hline
        \texttt{tok} & preprocessor token \\
        \texttt{ident} & preprocessor identifier \\
        \texttt{t} & Epilepsy term \\
        \texttt{a} & Epilepsy term used as an argument \\
        \hline
    \end{tabular}
\end{notation}

\section{Reduction Semantics}

We define a reduction semantics for Epilepsy \ref{ReductionSemantics}. The abstract
machine executes configurations of the form $\langle K; F; A; C \rangle$:

\begin{itemize}
    \item $K$ is a continuation of the form $\langle K; F; A; C \rangle$, where
    $C$ includes the $?$ sign denoting a result passed into a continuation.
    For example, let $K$ be $\langle K'; (1, 2, 3); v(x) \ ? \rangle$,
    then $K(v(y))$ is $\langle K'; (1, 2, 3); v(x) \ v(y) \rangle$. A special
    continuation $halt$ terminates the abstract machine and substitutes itself
    with a provided result. For example, when the abstract machine encounters
    $halt(1 + 2)$, it will just stop and paste $1 + 2$.

    \item $F$ is a left folder of the form $(acc, \overline{tok}) \to acc$. It is used
    to flexibly append a newly evaluated term to an accumulator without extra reduction
    steps. There are the only two folders:
    \begin{itemize}
        \item $fappend(acc, \overline{tok}) \coloneqq acc \ \overline{tok}$
        \item $fcomma(acc, \overline{tok}) \coloneqq if (acc \ is \ ()) \ then \ \overline{tok} \ else \ acc \ "," \ \overline{tok}$
    \end{itemize}

    \item $A$ (accumulator) is a sequence of already computed results.

    \item $C$ (control) is a sequence of terms upon which the abstract
    machine is operating right now.
\end{itemize}

\begin{figure}
    \caption{Reduction Semantics}

    \begin{align*}
        (v): & \ \langle K; F; A; \texttt{v}(\overline{tok}) \ \overline{t} \rangle \to
            \langle K; F; F(A, \overline{tok}); \overline{t} \rangle \\
        (op): & \ \langle K; F; A; \texttt{EPILEPSY\_CALL}(\overline{t}, \overline{a}) \ \overline{t'} \rangle \to \\
            & \langle \langle K; F; A; \texttt{EPILEPSY\_CALL}(?, \overline{a}) \ \overline{t'} \rangle; fappend; (); \overline{t} \rangle \\
        (args): & \ \langle K; F; A; \texttt{EPILEPSY\_CALL}(ident, \overline{a}) \ \overline{t} \rangle \to \\
            & \langle \langle K; F; A; ident(?) \ \overline{t} \rangle; fcomma; (); \overline{a} \rangle \\
        (end): & \ \langle K; F; A; () \rangle \to K(A) \\
        (start): & \ \texttt{EPILEPSY\_CALL}(\overline{t}) \to \langle halt; fappend; (); \overline{t} \rangle
    \end{align*}
    \label{ReductionSemantics}
\end{figure}

Notes:

\begin{itemize}
    \item Epilepsy follows applicative evaluation strategy \cite{ApplicativeEvaluationStrategy}.

    \item Look at $(args)$. Epilepsy generates a usual C-style macro invocation with
    fully evaluated arguments, which will be then expanded by the preprocessor, resulting
    in yet another concrete sequence of Epilepsy terms to be evaluated by the computational
    rules.
    \item With the current implementation, at most $2^{16}$ reduction steps are
    possible. After exceeding this limit, Epilepsy will not be able to perform reduction
    of a given metaprogram anymore.
\end{itemize}

\subsection{Examples}

Take the following code:

\begin{minted}{c}
#define X(op)        call(op, v(123))
#define CALL_X(_123) call(X, v(ID))
#define ID(x)        v(x)
\end{minted}

See how \texttt{EPILEPSY\_CALL(X, v(CALL\_X))} is evaluated:

\begin{example}[Evaluation of terms]
\small
\begin{align*}
    \texttt{EPILEPSY\_EVAL}(\texttt{EPILEPSY\_CALL}(X, \texttt{v}(\texttt{CALL\_X}))) & \to (start) \\
    \langle halt; fappend; (); \texttt{EPILEPSY\_CALL}(X, \texttt{v}(\texttt{CALL\_X})) \rangle & \to (args) \\
    \langle \langle halt; fappend; (); \texttt{X}(?) \rangle; fcomma; (); \texttt{v}(\texttt{CALL\_X}) \rangle & \to (v) \\
    \langle \langle halt; fappend; (); \texttt{X}(?) \rangle; fcomma; \texttt{CALL\_X}; () \rangle & \to (end) \\
    \langle halt; fappend; (); \texttt{EPILEPSY\_CALL}(\texttt{CALL\_X}, \texttt{v}(123)) \rangle & \to (args) \\
    \langle \langle halt; fappend; (); \texttt{CALL\_X}(?) \rangle; fcomma; (); \texttt{v}(123) \rangle & \to (v) \\
    \langle \langle halt; fappend; (); \texttt{CALL\_X}(?) \rangle; fcomma; 123; () \rangle & \to (end) \\
    \langle halt; fappend; (); \texttt{EPILEPSY\_CALL}(X, \texttt{v}(ID)) \rangle & \to (args) \\
    \langle \langle halt; fappend; (); \texttt{X}(?) \rangle; fcomma; (); \texttt{v}(ID) \rangle & \to (v) \\
    \langle \langle halt; fappend; (); \texttt{X}(?) \rangle; fcomma; ID; \rangle & \to (end) \\
    \langle halt; fappend; (); \texttt{EPILEPSY\_CALL}(ID, \texttt{v}(123)) \rangle & \to (args) \\
    \langle \langle halt; fappend; (); \texttt{ID}(?) \rangle; fcomma; (); \texttt{v}(123) \rangle & \to (v) \\
    \langle \langle halt; fappend; (); \texttt{ID}(?) \rangle; fcomma; 123; () \rangle & \to (end) \\
    \langle halt; fappend; (); \texttt{v}(123) \rangle & \to (v) \\
    \langle halt; fappend; 123; () \rangle & \to (end) \\
    halt(123) &
\end{align*}
\normalsize
\end{example}

The analogous version written in ordinary C looks like this:

\begin{minted}{c}
#define X(op)        op(123)
#define CALL_X(_123) X(ID)
#define ID(x)        x
\end{minted}

However, unlike the Epilepsy version above, \texttt{X(CALL\_X)} gets blocked \cite{Blueprinting} due to the
second call to \texttt{X}. The trick is that Epilepsy performs evaluation step-by-step,
unlike the preprocessor:

\begin{itemize}
    \item The Epilepsy version: \texttt{X(CALL\_X)} expands to \texttt{EPILEPSY\_CALL(CALL\_X, v(123))}.
    This expansion does not contain \texttt{X}, and therefore \texttt{X} is \textbf{not}
    blocked by the preprocessor.

    \item The ordinary version: \texttt{X(CALL\_X)} expands to \texttt{X(ID)}. This expansion
    does contains \texttt{X}, and therefore \texttt{X} is blocked by the preprocessor.
\end{itemize}

\section{Properties}

\subsection{Progress}

\begin{proposition}[Progress]
Either $\langle K; F; A; \overline{t} \rangle \to \langle K; F; A; \overline{t'} \rangle$ or \\
$\langle K; F; A; \overline{t} \rangle \to halt(\overline{x})$.
\end{proposition}

\begin{proof}
By inspection of \ref{ReductionSemantics}.
\end{proof}

\section{Caveats}

\begin{itemize}
\item Consider this scenario:
    \begin{itemize}
        \item You call \texttt{FOO(1, 2, 3)}
        \item It gets expanded by the preprocessor (not by Epilepsy)
        \item Its expansion contains \texttt{FOO}
    \end{itemize}
Then \texttt{FOO} gets blocked \cite{Blueprinting} by the preprocessor, e.g. Epilepsy cannot handle ordinary
macro recursion; you must use \texttt{EPILEPSY\_CALL} to be sure that recursive calls
will behave as expected. I therefore recommend to use only primitive C-style macros, e.g.
for performance reasons or because of you cannot express them in terms of Epilepsy.
\end{itemize}

\emergencystretch=1em
\printbibliography

\end{document}
